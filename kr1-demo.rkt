#lang scheme/base
;(((let ((t /)) (lambda (n) (lambda (x) (t x n)))) 2) 10)


;I
;Реализуйте функцию (taskI lst), которая принимает список чисел
;и возвращает список номеров минимального элемента списка (если минимум в списке один, то просто его номер).
;Нумерация элементов списка начинается с нуля. Элементы списка-результата идут по убыванию.
;Если исходный список пуст, выдаётся пустой список.
;Выберите и обязательно используйте в своём решении уместные функции высших порядков для работы со списками,
;такие как filter, map, foldl и т. п. Пример: (taskI (list -1 0 1 -1 0 1 -1)) => (6 3 0)
;Указание к задаче I: Каково минимальное количество проходов по lst для решения?
(define (taskI lst)
  (if (null? lst) null
      (cddr (foldl (lambda (x y) (let ((min-elem (car y)) (next-pos (add1 (cadr y))))
                                   (cond ((< x min-elem) (list* x next-pos (list next-pos)))
                                         ((= x min-elem) (list* x next-pos (cons next-pos (cddr y))))
                                         (else (list* min-elem next-pos (cddr y))))))
                   (list (car lst) -1) lst))
      )
  )

;II
;Квадродеревом называется следующий способ представления растровых черно-белых изображений:
;1) Если изображение целиком белое, то оно представляется квадродеревом из одной «белой» вершины.
;Значение такого квадродерева: 0 [ноль].
;2) Если изображение целиком чёрное, то оно представляется квадродеревом из одной «чёрной» вершины.
;Значение такого квадродерева: 1[единица].
;3) Если на изображении есть и чёрные и белые участки, то оно делится на 4 равные части
;(верхнюю левую, верхнюю правую, нижнюю левую, нижнюю правую) и представляется квадродеревом,
;состоящим из корневой вершины и четырёх поддеревьев, которые описывают части изображения.
;Обозначим значения поддеревьев: <верхлевд>, <верхправд>, <нижнлевд>, <нижнправд>
;тогда значением всего дерева будет вектор из четырёх элементов, т. е. результат вычисления
;(vector <верхлевд> <верхпправд> <нижнлевд> <нижнправд>).
;Пример квадродерева: #(1 0 0 #(1 1 1 0))
;Составьте функцию (taskII t s), которая находит суммарную площадь чёрных участков изображения, считая,
;что площадь всего участка, описываемого квадродеревом t, равна s. Результат для дерева из примера равен 7,
;если площадь квадрата равна 16.
(require racket/vector)
;(taskII #(1 0 0 #(1 1 1 0)) 16) -> 7
;(taskII #(1 0 0 #(1 1 1 #(1 1 1 0))) 64) -> 31
;(taskII #(1 0 0 #(1 0 1 #(1 1 1 1))) 64) -> 28
;(taskII #(#(1 0 0 0) 0 1 #(0 0 0 1)) 16) -> 6
(define (taskII t s)
  ; считаю, что на вход подается корректное дерево
  (foldl (lambda (x y) (if (vector? x)
                           (+ y (taskII x (/ s 4)))
                           (if (= x 1) (+ y (/ s 4)) y))) 0 (vector->list t))
  )

;III
;Реализуйте функцию (taskIII lst), которая возвращает список,
;получаемый из исходного списка списков прибавлением 1 к всем элементам списков,
;являющихся элементами списка, и имеющих наибольшую длину.
;Описание функции taskIII не должно быть рекурсивным.
;В решении следует использовать ограниченный набор функций: функции высшего порядка (filter, foldl, map и т. п.),
;базовые функции работы со списками (car, cdr, cons),
;арифметические функции (+, -, *, /, add1 и т. п.), функции сравнения.
;Пример: (taskIII '((1) (2 3) (4 5) (6))) => ((1) (3 4) (5 6) (6))
(define (taskIII lst)
  (if (null? lst) null
      (let ((max-len (foldl (lambda (x y) (let ((len-x (length x)))(if (> len-x y) len-x y)))
                            (length (car lst)) (cdr lst))))
        (map (lambda (x) (if (= (length x) max-len) (map add1 x) x)) lst)
        )
      )
  )

;IV
;Реализуйте функцию (taskIV-сс t s cc), являющуюся версией (taskII t s),
;которая составлена в стиле передачи продолжений.
;(taskIV-cc #(1 0 0 #(1 1 1 0)) 16 (lambda (x) x))
;(taskIV-cc #(1 0 0 #(1 1 1 #(1 1 1 0))) 64 (lambda (x) x))
(define (taskIV t s)
  (cond ((equal? t #()) 0)
        ((vector? (vector-ref t 0)) (+ (taskIV (vector-ref t 0) (/ s 4)) (taskIV (vector-drop t 1) s)))
        ((= (vector-ref t 0) 1) (+ (/ s 4) (taskIV (vector-drop t 1) s)))
        (else (taskIV (vector-drop t 1) s))
        )
  )

(define (taskIV-cc t s cc)
  (cond ((equal? t #()) (cc 0))
        ((vector? (vector-ref t 0)) (taskIV-cc (vector-ref t 0) (/ s 4) (lambda (x) (taskIV-cc (vector-drop t 1) s (lambda (y) (cc (+ x y)))))))
        ((= (vector-ref t 0) 1) (taskIV-cc (vector-drop t 1) s (lambda (x) (cc (+ (/ s 4) x)))))
        (else (cc (taskIV-cc (vector-drop t 1) s (lambda (x) x))))
        )
  )

;V
;Функция (taskV f1 f2 ... fn) возвращает в качестве результата функцию,
;являющуюся суперпозицией функций от одного аргумента f1, f2, ... fn (n>0 натуральное)
;так что ((taskV f1 f2 ... fn) x) сначала вычислит результат применения f1 к х,
;затем f2 к полученному результату (f1 х), и т. д. до fn.
;Реализуйте функцию taskV, считая, что хотя бы 1 аргумент обязательно должен быть в любом её вызове.
;((taskV (lambda (x) x) (lambda(x) (* x x))) 2) -> 4
;((taskV (lambda (x) (+ x 1)) (lambda(x) (* x x)) (lambda(x) (* 3 x))) 1) -> 12
(define (taskV f1 . params)
  (let loop ((f f1) (params params))
    (if (null? params) f
        (loop (lambda (x) ((car params) (f x))) (cdr params)))
    )
  )