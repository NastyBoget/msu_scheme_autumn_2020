#lang scheme/base

;I
;Реализуйте функцию (fun1 lst), которая принимает список целых чисел и возвращает значение элемента списка,
;ближайшее к значению минимального элемента, но не равное ему. Если исходный список таков, что искомого значения нет,
;то результат – пустой список. Функции min, max, argmin и argmax использовать нельзя.
;Выберите и обязательно используйте в своём решении уместные функции высших порядков для работы со списками,
;такие как filter, map, foldl и т. п. Примеры:
;(fun1 (list)) => ()
;(fun1 '(1 1)) => ()
;(fun1 (list -1 0 1 -1 0 1 -1)) => 0
(define (fun1 lst)
  (if (or (null? lst) (null? (cdr lst))) null
      (let ((min-elem (foldl (lambda (x y) (if (< x y) x y))
                              (car lst) lst)))
        (foldl (lambda (x y) (cond ((and (null? y) (> x min-elem)) x)
                                   ((and (not (null? y)) (< x y) (> x min-elem)) x)
                                   (else y)))
               null
               lst)
        )
      )
  )

;(foldr - 0 '(1 2 3 4))

;II
;Реализуйте функции (fun2а n) и (fun2b n). Каждая из функций строит список из составных делителей целого положительного числа n.
;Элементы списка-результата должны идти по убыванию без повторов. Функцию sort не используйте. Предложите две реализации:
;II.a) (fun2a n), порождающую рекурсивный процесс;
;II.b) (fun2b n), порождающую итеративный процесс.
;Примеры:
;(fun2a 1) => ()
;(fun2a 2) => ()
;(fun2a 12) => (12 6 4)

(define (is-prime x)
  (if (< x 2) #f
      (null? (filter (lambda (y) (= (remainder x y) 0))
                     (cdr(build-list (round (/ x 2)) add1)))))
  )

(define (fun2a n)
  (if (= n 1) null
      (reverse (filter (lambda (x) (not (is-prime x)))
                       (filter (lambda (y) (= (remainder n y) 0))
                               (cdr(build-list (round (/ n 2)) add1))))))
  )

;III
;Праймориалом называют аналог факториала, множителями которого являются не подряд идущие натуральные числа, а простые числа.
;P0#=1, P1#=P0# * 2=2, P2#=P1# * 3=6, P3#=P2# * 5=30, ... PN#=PN-1# * pN, где pN – N-ое простое число.
;Опишите функцию (fun3 n), находящую для целого положительного n праймориал Pn#.
;Примеры:
;(fun3 0) => 1
;(fun3 4) => 210
;(fun3 10) => 6469693230

(require math/number-theory)
(define (fun3 x)
  (if (= x 0) 1
      (cadr (foldl (lambda (x y) (let ((next (next-prime (car y))))
                                   (list next (* next (cadr y)))))
                   '(1 1) (build-list x values))))
  )

;IV
;Рассмотрим пустые и непустые бинарные деревья, вершины которых хранят числа.
;Будем представлять такие непустые деревья векторами, вычисляемыми как (vector <число при вершине> <левоеПоддерево> <правоеПоддерево>),
;где поддеревья – такого же рода вектора. Пустые деревья будем представлять пустыми векторами – #().
;Реализуйте функцию (fun4 tree r1 r2), возвращающую количество вершин с отрицательными числами, расположенных в дереве tree, таких что расстояние от них до корня дерева лежит между r1 и r2.
;Может быть так, что r1 > r2, или r2 < r1, или r1 = r2. Во всех этих случаях функция в зависимости от дерева может вернуть ненулевой ответ.
;Расстояние от корня до корня = 0, от корня до его непосредственного потомка = 1. И т. п. Если min(r1, r2) больше высоты дерева, то результат – нуль.
;Примеры:
;(fun4 #(1 #(-1 #(3 #() #()) #(3 #() #())) #(-2 #() #())) 2 1) => 2
;(fun4 #() 1 10) => 0
;(fun4 #(-10 #() #()) 0 0) => 1
;(fun4 #(1 #(-1 #(4 #(-1 #() #()) #(-1 #() #())) #(5 #() #())) #(3 #(6 #() #()) #(7 #() #()))) 0 1) => 1
(define (fun4 tree r1 r2)
  (cond ((equal? tree #()) 0)
        ((and (or (= r1 0) (= r2 0) (< (* r1 r2) 0))
              (< (vector-ref tree 0) 0))
         (+ 1 (fun4 (vector-ref tree 1) (- r1 1) (- r2 1))
            (fun4 (vector-ref tree 2) (- r1 1) (- r2 1))))
        (else (+ (fun4 (vector-ref tree 1) (- r1 1) (- r2 1))
                 (fun4 (vector-ref tree 2) (- r1 1) (- r2 1))))
        )
  )

;V
;Перепишите решение задачи IV в стиле передачи продолжений, так чтобы порождался итеративный процесс.
;Сигнатура функции (fun5-cps tree r1 r2 cc). Функция должна работать с любым cc. 
;Пример:
;(fun5 #() 1 10 add1) => 1
;(fun5 #(1 #(-1 #(3 #() #()) #(3 #() #())) #(-2 #() #())) 2 1 (lambda (x) x)) => 2
;(fun5 #() 1 10 (lambda (x) x)) => 0
;(fun5 #(-10 #() #()) 0 0 (lambda (x) x)) => 1
(define (fun5 tree r1 r2 cc)
  (cond ((equal? tree #()) (cc 0))
        ((and (or (= r1 0) (= r2 0) (< (* r1 r2) 0))
              (< (vector-ref tree 0) 0))
         (fun5 (vector-ref tree 1) (- r1 1) (- r2 1)
               (lambda (x)(fun5 (vector-ref tree 2)
                                (- r1 1)
                                (- r2 1) (lambda (y) (cc (+ 1 x y)))))))
        (else (fun5 (vector-ref tree 1) (- r1 1) (- r2 1)
                    (lambda (x)(fun5 (vector-ref tree 2)
                                     (- r1 1)
                                     (- r2 1) (lambda (y) (cc (+ x y)))))))
        )
  )

